//apply the dependencies defined in the customized plugin and then the sub projects can access them
apply from: 'dependencies.gradle'

/**
 * Apply global settings to all projects
 */
allprojects {
  buildscript {
    repositories {
      mavenLocal() //firstly try to retrieve jars from local maven repository
      maven {
        //then try to retrieve jars from nexus
        url nexusPublicUrl
      }
      jcenter()
    }

    dependencies {
      classpath "io.spring.gradle:dependency-management-plugin:1.0.3.RELEASE"
      classpath libs.'spring-boot-gradle-plugin'
//      classpath libs.'dependency-management-plugin'  //todo : not sure if it is required here
      classpath libs.'sonarqube-gradle-plugin'
      classpath libs.'spring-cloud-contract-gradle-plugin'
    }
  }
}

subprojects { subpro ->
  apply plugin: 'java'
  apply plugin: 'maven'
  apply plugin: 'eclipse'
  apply plugin: 'idea'
  apply plugin: 'jacoco'
  apply plugin: 'pmd'
  apply plugin: 'checkstyle'
  apply plugin: 'findbugs'
  apply plugin: 'project-report'

  /*apply following plugins in sub projects as needed*/
//  apply plugin: 'org.sonarqube'
//  apply plugin: "io.spring.dependency-management"
//  apply plugin: 'org.springframework.boot'
  apply plugin: 'maven-publish'
//  apply plugin: 'spring-cloud-contract'

  sourceCompatibility = projectInfo.sourceCompatibility
  targetCompatibility = projectInfo.targetCompatibility

  group = projectInfo.group
  version = projectInfo.version

  repositories {
    mavenLocal() //firstly try to retrieve jars from local maven repository
    maven {
      //then try to retrieve jars from nexus
      url nexusPublicUrl
    }
    jcenter()
  }

  /* configurations {
     //exclude commons-loggin since we use logback+slf4j libs
     all*.exclude module: 'commons-logging'
   }*/

  task wrapper(type: Wrapper) {
    gradleVersion = '4.4.1'
  }

  /**
   * List all jars this project depends on
   */
  task listJars(description: 'Display all dependencies.') {
    doLast {
      configurations.compile.each { File file -> println "\t" + file.name }
    }
  }

/**
 * Configuration for checkstyle, the google checks file is applied by default
 */
  checkstyle {
    toolVersion = "7.8.1"
    sourceSets = [sourceSets.main]
    configFile = project(":").file('config/checkstyle/google_checks.xml')
    ignoreFailures = true
    showViolations = true
  }

//the test code is ignored
  checkstyleTest {
    enabled = false
  }

  tasks.withType(Checkstyle) {
    reports {
      xml.enabled false
      html.enabled true
    }
  }

/**
 * Configuration for FindBugs
 */
  findbugs {
    toolVersion = "3.0.1"
    ignoreFailures = true
    findbugsTest.enabled = false
    sourceSets = [sourceSets.main]
    effort = "max"
  }

  tasks.withType(FindBugs) {
    reports {
      xml.enabled = false
      html.enabled = true
    }
  }

/**
 * Configuration for PMD
 */
  pmd {
    toolVersion = '6.0.0'
    ignoreFailures = true
    pmdTest.enabled = false
    ruleSetFiles = project(":").files("config/pmd/pmd-rulesets.xml")
  }

  tasks.withType(Pmd) {
    reports {
      xml.enabled = false
      html.enabled = true
    }
  }

/**
 * Configuration for Jacoco
 */
  jacoco {
    toolVersion = "0.8.0"
  }

  jacocoTestReport {
    group = "Reporting"
    reports {
      xml.enabled false
      html.enabled true
      html.destination project(":").file("${buildDir}/reports/coverage")
    }
  }

  check.dependsOn jacocoTestReport

  /**
   * Configuration for sonarqube
   */
//    sonarqube {
//        properties {
//            property "sonar.java.coveragePlugin", "jacoco"
//            property "sonar.exclusion", "src/main/resources/**"
//            property "sonar.projectName", rootProject.name
//            property "sonar.projectVersion", "${projectInfo.version}"
//            property "onar.jacoco.reportPaths", "${buildDir}/jacoco/test.exec"
//            property "sonar.exclusions", "build/**/*"
//        }
//    }
//    project.tasks["sonarqube"].dependsOn build

  /**
   * The task to generate a sources jar
   */
  task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
  }

/**
 * The task to generate a javadoc jar
 */
  task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
  }

//in addition generate the sources and java doc jars locally
  artifacts {
    archives sourcesJar
//    archives javadocJar
  }

  publish {
    dependsOn assemble
  }

  publishing {
    publications {
      maven(MavenPublication) {
        //only publish javadoc and spring boot executable jars to nexus
        artifact javadocJar
        artifact jar
      }
/*
      //for publishing contract test related stubs jar, enable it as needed
      stubs(MavenPublication) {
        //rename the stubs jar to avoid conflict
        artifactId "${project.name}-contract"
        artifact verifierStubsJar
      }*/
    }
    repositories {
      maven {
        credentials {
          username = nexusUsername
          password = nexusPassword
        }

        if (project.version.contains("-SNAPSHOT")) {
          url snapshotUrl
        } else {
          url releaseUrl
        }
      }
    }
  }

/**
 * for spring contract test, enable it as needed
 */
  /* contracts {
     packageWithBaseClasses = "${projectInfo.group}.backend.contracts"

     //specify the directory of contract DSL files
     contractsDslDir = project(":").file("src/contracts")
   }*/

}
